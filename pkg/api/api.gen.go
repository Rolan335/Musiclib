// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// SongGet defines model for SongGet.
type SongGet struct {
	Group       string             `json:"group"`
	Id          int                `json:"id"`
	Link        string             `json:"link"`
	ReleaseDate openapi_types.Date `json:"releaseDate"`
	Text        string             `json:"text"`
	Title       string             `json:"title"`
}

// SongPatch defines model for SongPatch.
type SongPatch struct {
	Group       *string             `json:"group,omitempty"`
	Link        *string             `json:"link,omitempty"`
	ReleaseDate *openapi_types.Date `json:"releaseDate,omitempty"`
	Text        *string             `json:"text,omitempty"`
	Title       *string             `json:"title,omitempty"`
}

// GetSongsParams defines parameters for GetSongs.
type GetSongsParams struct {
	// Group Фильтрация по имени исполнителя
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Title Фильтрация по названию песни
	Title *string `form:"title,omitempty" json:"title,omitempty"`

	// Text Поиск по тексту песни (подстрока)
	Text *string `form:"text,omitempty" json:"text,omitempty"`

	// DateFrom Фильтрация — песни после указанной даты (YYYY-MM-DD)
	DateFrom *openapi_types.Date `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Фильтрация — песни до указанной даты (YYYY-MM-DD)
	DateTo *openapi_types.Date `form:"date_to,omitempty" json:"date_to,omitempty"`

	// Page Номер страницы
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Количество элементов на странице
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`
}

// PostSongsJSONBody defines parameters for PostSongs.
type PostSongsJSONBody struct {
	Group *string `json:"group,omitempty"`
	Title *string `json:"title,omitempty"`
}

// PatchSongsIdJSONBody defines parameters for PatchSongsId.
type PatchSongsIdJSONBody = map[string]interface{}

// GetSongsIdTextParams defines parameters for GetSongsIdText.
type GetSongsIdTextParams struct {
	Page     *int `form:"page,omitempty" json:"page,omitempty"`
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// PostSongsJSONRequestBody defines body for PostSongs for application/json ContentType.
type PostSongsJSONRequestBody PostSongsJSONBody

// PatchSongsIdJSONRequestBody defines body for PatchSongsId for application/json ContentType.
type PatchSongsIdJSONRequestBody = PatchSongsIdJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Получение данных библиотеки с фильтрацией по всем полям и пагинацией
	// (GET /songs)
	GetSongs(c *gin.Context, params GetSongsParams)
	// Добавление новой песни
	// (POST /songs)
	PostSongs(c *gin.Context)
	// Удаление песни
	// (DELETE /songs/{id})
	DeleteSongsId(c *gin.Context, id int)
	// Изменение данных песни
	// (PATCH /songs/{id})
	PatchSongsId(c *gin.Context, id int)
	// Получение текста песни с пагинацией по куплетам
	// (GET /songs/{id}/text)
	GetSongsIdText(c *gin.Context, id int, params GetSongsIdTextParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetSongs operation middleware
func (siw *ServerInterfaceWrapper) GetSongs(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongsParams

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", c.Request.URL.Query(), &params.Group)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter group: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "title" -------------

	err = runtime.BindQueryParameter("form", true, false, "title", c.Request.URL.Query(), &params.Title)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter title: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "text" -------------

	err = runtime.BindQueryParameter("form", true, false, "text", c.Request.URL.Query(), &params.Text)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter text: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "date_from" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_from", c.Request.URL.Query(), &params.DateFrom)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter date_from: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "date_to" -------------

	err = runtime.BindQueryParameter("form", true, false, "date_to", c.Request.URL.Query(), &params.DateTo)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter date_to: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "page_size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_size", c.Request.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page_size: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSongs(c, params)
}

// PostSongs operation middleware
func (siw *ServerInterfaceWrapper) PostSongs(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSongs(c)
}

// DeleteSongsId operation middleware
func (siw *ServerInterfaceWrapper) DeleteSongsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteSongsId(c, id)
}

// PatchSongsId operation middleware
func (siw *ServerInterfaceWrapper) PatchSongsId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PatchSongsId(c, id)
}

// GetSongsIdText operation middleware
func (siw *ServerInterfaceWrapper) GetSongsIdText(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongsIdTextParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", c.Request.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter page: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", c.Request.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pageSize: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSongsIdText(c, id, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/songs", wrapper.GetSongs)
	router.POST(options.BaseURL+"/songs", wrapper.PostSongs)
	router.DELETE(options.BaseURL+"/songs/:id", wrapper.DeleteSongsId)
	router.PATCH(options.BaseURL+"/songs/:id", wrapper.PatchSongsId)
	router.GET(options.BaseURL+"/songs/:id/text", wrapper.GetSongsIdText)
}
